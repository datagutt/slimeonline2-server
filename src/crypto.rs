//! RC4 encryption/decryption for Slime Online 2 protocol
//!
//! The client uses hardcoded RC4 keys:
//! - Client encrypts outgoing with CLIENT_ENCRYPT_KEY
//! - Client decrypts incoming with CLIENT_DECRYPT_KEY
//!
//! Server must reverse this:
//! - Server decrypts incoming with CLIENT_ENCRYPT_KEY
//! - Server encrypts outgoing with CLIENT_DECRYPT_KEY
//!
//! IMPORTANT: RC4 cipher state is re-initialized for each message.

use crate::constants::{CLIENT_DECRYPT_KEY, CLIENT_ENCRYPT_KEY};

/// RC4 cipher implementation
struct Rc4 {
    state: [u8; 256],
    i: u8,
    j: u8,
}

impl Rc4 {
    /// Create a new RC4 cipher with the given key
    fn new(key: &[u8]) -> Self {
        let mut state = [0u8; 256];
        
        // Initialize state array
        for (i, s) in state.iter_mut().enumerate() {
            *s = i as u8;
        }
        
        // Key scheduling algorithm (KSA)
        let mut j: u8 = 0;
        for i in 0..256 {
            j = j.wrapping_add(state[i]).wrapping_add(key[i % key.len()]);
            state.swap(i, j as usize);
        }
        
        Self { state, i: 0, j: 0 }
    }
    
    /// Apply keystream to data (XOR with generated bytes)
    fn apply_keystream(&mut self, data: &mut [u8]) {
        for byte in data.iter_mut() {
            self.i = self.i.wrapping_add(1);
            self.j = self.j.wrapping_add(self.state[self.i as usize]);
            self.state.swap(self.i as usize, self.j as usize);
            
            let k = self.state[(self.state[self.i as usize].wrapping_add(self.state[self.j as usize])) as usize];
            *byte ^= k;
        }
    }
}

/// Decrypt a message received from the client.
///
/// Uses the CLIENT_ENCRYPT_KEY because the client encrypted with this key.
/// RC4 is symmetric, so the same key is used for encryption and decryption.
///
/// # Arguments
/// * `data` - The encrypted message bytes (modified in place)
pub fn decrypt_client_message(data: &mut [u8]) {
    let mut cipher = Rc4::new(CLIENT_ENCRYPT_KEY);
    cipher.apply_keystream(data);
}

/// Encrypt a message to send to the client.
///
/// Uses the CLIENT_DECRYPT_KEY because the client will decrypt with this key.
/// RC4 is symmetric, so the same key is used for encryption and decryption.
///
/// # Arguments
/// * `data` - The plaintext message bytes (modified in place)
pub fn encrypt_server_message(data: &mut [u8]) {
    let mut cipher = Rc4::new(CLIENT_DECRYPT_KEY);
    cipher.apply_keystream(data);
}

/// Decrypt a message with a custom key (for testing or alternative encryption).
#[allow(dead_code)]
pub fn decrypt_with_key(data: &mut [u8], key: &[u8]) {
    let mut cipher = Rc4::new(key);
    cipher.apply_keystream(data);
}

/// Encrypt a message with a custom key (for testing or alternative encryption).
#[allow(dead_code)]
pub fn encrypt_with_key(data: &mut [u8], key: &[u8]) {
    let mut cipher = Rc4::new(key);
    cipher.apply_keystream(data);
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_rc4_roundtrip() {
        let original = b"Hello, Slime World!";
        let mut data = original.to_vec();

        // Simulate client encrypting a message
        encrypt_with_key(&mut data, CLIENT_ENCRYPT_KEY);

        // Server decrypts
        decrypt_client_message(&mut data);

        assert_eq!(&data, original);
    }

    #[test]
    fn test_server_to_client_roundtrip() {
        let original = b"Welcome to the server!";
        let mut data = original.to_vec();

        // Server encrypts
        encrypt_server_message(&mut data);

        // Simulate client decrypting
        decrypt_with_key(&mut data, CLIENT_DECRYPT_KEY);

        assert_eq!(&data, original);
    }

    #[test]
    fn test_encryption_modifies_data() {
        let original = b"Test message";
        let mut data = original.to_vec();

        encrypt_server_message(&mut data);

        // Encrypted data should be different from original
        assert_ne!(&data, original);
    }

    #[test]
    fn test_different_keys_produce_different_output() {
        let original = b"Test message";
        let mut data1 = original.to_vec();
        let mut data2 = original.to_vec();

        encrypt_with_key(&mut data1, CLIENT_ENCRYPT_KEY);
        encrypt_with_key(&mut data2, CLIENT_DECRYPT_KEY);

        // Different keys should produce different encrypted output
        assert_ne!(data1, data2);
    }

    #[test]
    fn test_empty_data() {
        let mut data: Vec<u8> = vec![];
        decrypt_client_message(&mut data);
        encrypt_server_message(&mut data);
        assert!(data.is_empty());
    }

    #[test]
    fn test_binary_data() {
        // Test with binary data including null bytes
        let original: Vec<u8> = vec![0x00, 0x01, 0x02, 0xFF, 0xFE, 0x00, 0x10];
        let mut data = original.clone();

        encrypt_server_message(&mut data);
        decrypt_with_key(&mut data, CLIENT_DECRYPT_KEY);

        assert_eq!(data, original);
    }

    #[test]
    fn test_known_vector() {
        // Test with a known RC4 test vector
        let key = b"Key";
        let plaintext = b"Plaintext";
        let mut data = plaintext.to_vec();

        encrypt_with_key(&mut data, key);

        // RC4("Key", "Plaintext") is a known value
        // This ensures our implementation is correct
        let expected: [u8; 9] = [0xBB, 0xF3, 0x16, 0xE8, 0xD9, 0x40, 0xAF, 0x0A, 0xD3];
        assert_eq!(data, expected);
    }
}
